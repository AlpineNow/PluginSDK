<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>SQLGenerator - com.alpine.sql.SQLGenerator</title>
          <meta name="description" content="SQLGenerator - com.alpine.sql.SQLGenerator" />
          <meta name="keywords" content="SQLGenerator com.alpine.sql.SQLGenerator" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'com.alpine.sql.SQLGenerator';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/trait_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="com">com</a>.<a href="../package.html" class="extype" name="com.alpine">alpine</a>.<a href="package.html" class="extype" name="com.alpine.sql">sql</a></p>
        <h1>SQLGenerator</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">SQLGenerator</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>The purpose of SQLGenerator is to provide an object to facilitate the construction of commonly used SQL queries.
Because SQL generation can vary between different database types, each SQLGenerator is instantiated for a
particular database type.</p><p>For certain methods, when specifying table names, fully qualify and delimit as necessary
(i.e. &quot;schemaname&quot;.&quot;tablename&quot;). Delimiting is required for table names with non-standard characters
([A-Za-z][A-Za-z0-9]*). Not all databases support delimiters or non-standard characters (such as Teradata).
For those databases that support schemas, specifying the schema name is recommended.</p><p>For certain methods, when specifying column names, these must be a comma-separated string of columns
that one would find in a SELECT query. This can include expressions that are aliased
(i.e. sqlexpression AS aliasname). Any columns with non-standard characters should be delimited
(i.e. &quot;columnname&quot;). When SELECTing from more than one table, if column names are not unique,
then columns should be fully qualified (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;columnalias&quot;).</p><p>For certain methods, when specifying a source table, it is permissible to specify more than one table as a join
(i.e. table1 INNER JOIN table2 ON ...).</p><p>For certain methods, when specifying a whereClause, the literal &quot;WHERE&quot; should be included.
Note that we can include anything that follows a FROM clause here, such as GROUP BY, ORDER BY, etc.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="com.alpine.sql.SQLGenerator"><span>SQLGenerator</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="com.alpine.sql.SQLGenerator#dbType" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="dbType:com.alpine.sql.DatabaseType.TypeValue"></a>
      <a id="dbType:TypeValue"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbType</span><span class="result">: <a href="DatabaseType$$TypeValue.html" class="extype" name="com.alpine.sql.DatabaseType.TypeValue">TypeValue</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the DatabaseType.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the DatabaseType.TypeValue object that represents the database type. Each SQLGenerator is
instantiated for a particular database type.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the DatabaseType.TypeValue object that represents the database type of this SQLGenerator
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateTableAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateTableAsSelectSQL(selectQuery:String,destinationTable:String):String"></a>
      <a id="getCreateTableAsSelectSQL(String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateTableAsSelectSQL</span><span class="params">(<span name="selectQuery">selectQuery: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationTable">destinationTable: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a table based on a SELECT query,
not necessarily from any particular table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a table based on a SELECT query,
not necessarily from any particular table. The entire SELECT query must be supplied
to generate something like &quot;CREATE TABLE destinationTable AS selectQuery&quot;.
This method is useful for calls to UDFs or stored procedures that might be database-specific
and don't conform to selecting columns from a source table.</p><p>NOTE: Currently, this works only on certain databases like PostgreSQL, Greenplum, Oracle, MySQL, Teradata,
but not MSSQL, which does not support CREATE TABLE ... AS SELECT ....</p><p>Table name should be fully qualified and delimited, if necessary (i.e. &quot;schemaname&quot;.&quot;tablename&quot;).</p><p>selectQuery is not necessarily a SELECT query, but any query that can feed the CREATE TABLE statement.
</p></div><dl class="paramcmts block"><dt class="param">selectQuery</dt><dd class="cmt"><p>query (not necessary SELECT) to be used for CREATE TABLE</p></dd><dt class="param">destinationTable</dt><dd class="cmt"><p>name of destination table to be created from SELECT query</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateTableAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateTableAsSelectSQL(columns:String,sourceTable:String,destinationTable:String):String"></a>
      <a id="getCreateTableAsSelectSQL(String,String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateTableAsSelectSQL</span><span class="params">(<span name="columns">columns: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sourceTable">sourceTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationTable">destinationTable: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a table based on a SELECT query from an existing table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a table based on a SELECT query from an existing table.
For most databases, this is something like &quot;CREATE TABLE destinationTable AS SELECT columns FROM sourceTable&quot;</p><p>Table names should be fully qualified and delimited, if necessary (i.e. &quot;schemaname&quot;.&quot;tablename&quot;).
it is acceptable to specify a table join as the source table (i.e. table1 INNER JOIN table2 ...),
but in such cases, column names might not be unique and full qualification and aliasing may be
required (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;aliasname&quot;)
</p></div><dl class="paramcmts block"><dt class="param">columns</dt><dd class="cmt"><p>String of comma-separated columns to be SELECTed</p></dd><dt class="param">sourceTable</dt><dd class="cmt"><p>name of source table from which we SELECT</p></dd><dt class="param">destinationTable</dt><dd class="cmt"><p>name of destination table to be created from SELECT query</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateTableAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateTableAsSelectSQL(columns:String,sourceTable:String,destinationTable:String,whereClause:String):String"></a>
      <a id="getCreateTableAsSelectSQL(String,String,String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateTableAsSelectSQL</span><span class="params">(<span name="columns">columns: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sourceTable">sourceTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationTable">destinationTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="whereClause">whereClause: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a table based on a SELECT query from an existing table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a table based on a SELECT query from an existing table.
For most databases, this is something like
&quot;CREATE TABLE destinationTable AS SELECT columns FROM sourceTable whereClause&quot;</p><p>Table names should be fully qualified and delimited, if necessary (i.e. &quot;schemaname&quot;.&quot;tablename&quot;).
it is acceptable to specify a table join as the source table (i.e. table1 INNER JOIN table2 ...),
but in such cases, column names might not be unique and full qualification and aliasing may be
required (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;aliasname&quot;)</p><p>The specified WHERE clause should include the &quot;WHERE&quot; keyword. Note that this is simply SQL that
is appended to the query as &quot;SELECT columns FROM sourceTable whereClause&quot; and can include other
SQL outside of just a WHERE clause, such as GROUP BY, ORDER BY, etc.
</p></div><dl class="paramcmts block"><dt class="param">columns</dt><dd class="cmt"><p>String of comma-separated columns to be SELECTed</p></dd><dt class="param">sourceTable</dt><dd class="cmt"><p>name of source table from which we SELECT</p></dd><dt class="param">destinationTable</dt><dd class="cmt"><p>name of destination table to be created from SELECT query</p></dd><dt class="param">whereClause</dt><dd class="cmt"><p>where clause of the SELECT query, including the literal &quot;WHERE&quot; keyword</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateTableOrViewAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateTableOrViewAsSelectSQL(selectQuery:String,destinationTableOrView:String,isView:Boolean):String"></a>
      <a id="getCreateTableOrViewAsSelectSQL(String,String,Boolean):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateTableOrViewAsSelectSQL</span><span class="params">(<span name="selectQuery">selectQuery: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationTableOrView">destinationTableOrView: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="isView">isView: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a table or view based on a SELECT query,
not necessarily from any particular table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a table or view based on a SELECT query,
not necessarily from any particular table. The entire SELECT query must be supplied
to generate something like &quot;CREATE TABLE destinationTable AS selectQuery&quot;
or &quot;CREATE VIEW destinationTable AS selectQuery&quot;, depending on the isView parameter.
This method is useful for calls to UDFs or stored procedures that might be database-specific
and don't conform to selecting columns from a source table.</p><p>NOTE: Currently, creating a table works only on certain databases but not MSSQL,
which does not support CREATE TABLE ... AS SELECT ....</p><p>Table or view name should be fully qualified and delimited, if necessary
(i.e. &quot;schemaname&quot;.&quot;tablename&quot; or &quot;schemaname&quot;.&quot;viewname&quot;).</p><p>selectQuery is not necessarily a SELECT query, but any query that can feed the CREATE TABLE statement.
</p></div><dl class="paramcmts block"><dt class="param">selectQuery</dt><dd class="cmt"><p>query (not necessary SELECT) to be used for CREATE TABLE</p></dd><dt class="param">destinationTableOrView</dt><dd class="cmt"><p>name of destination table to be created from SELECT query</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateTableOrViewAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateTableOrViewAsSelectSQL(columns:String,sourceTable:String,destinationTable:String,isView:Boolean):String"></a>
      <a id="getCreateTableOrViewAsSelectSQL(String,String,String,Boolean):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateTableOrViewAsSelectSQL</span><span class="params">(<span name="columns">columns: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sourceTable">sourceTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationTable">destinationTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="isView">isView: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a table or view based on a SELECT query from an existing table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a table or view based on a SELECT query from an existing table.
For most databases, this is something like &quot;CREATE TABLE destinationTable AS SELECT columns FROM sourceTable&quot;
or &quot;CREATE VIEW destinationTable AS SELECT columns FROM sourceTable&quot;, depending on the isView parameter</p><p>Table and view names should be fully qualified and delimited, if necessary
(i.e. &quot;schemaname&quot;.&quot;tablename&quot;, &quot;schemaname&quot;.&quot;viewname&quot;).
it is acceptable to specify a table join as the source table (i.e. table1 INNER JOIN table2 ...),
but in such cases, column names might not be unique and full qualification and aliasing may be
required (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;aliasname&quot;)
</p></div><dl class="paramcmts block"><dt class="param">columns</dt><dd class="cmt"><p>String of comma-separated columns to be SELECTed</p></dd><dt class="param">sourceTable</dt><dd class="cmt"><p>name of source table from which we SELECT</p></dd><dt class="param">destinationTable</dt><dd class="cmt"><p>name of destination table or view to be created from SELECT query</p></dd><dt class="param">isView</dt><dd class="cmt"><p>true if generating a view, false if generating a table</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateTableOrViewAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateTableOrViewAsSelectSQL(columns:String,sourceTable:String,destinationTable:String,whereClause:String,isView:Boolean):String"></a>
      <a id="getCreateTableOrViewAsSelectSQL(String,String,String,String,Boolean):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateTableOrViewAsSelectSQL</span><span class="params">(<span name="columns">columns: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sourceTable">sourceTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationTable">destinationTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="whereClause">whereClause: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="isView">isView: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a table or view based on a SELECT query from an existing table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a table or view based on a SELECT query from an existing table.
For most databases, this is something like &quot;CREATE TABLE destinationTable AS SELECT columns FROM sourceTable whereClause&quot;
or &quot;CREATE VIEW destinationTable AS SELECT columns FROM sourceTable whereClause&quot;, depending on the isView parameter</p><p>Table and view names should be fully qualified and delimited, if necessary
(i.e. &quot;schemaname&quot;.&quot;tablename&quot;, &quot;schemaname&quot;.&quot;viewname&quot;).
it is acceptable to specify a table join as the source table (i.e. table1 INNER JOIN table2 ...),
but in such cases, column names might not be unique and full qualification and aliasing may be
required (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;aliasname&quot;)</p><p>The specified WHERE clause should include the &quot;WHERE&quot; keyword. Note that this is simply SQL that
is appended to the query as &quot;SELECT columns FROM sourceTable whereClause&quot; and can include other
SQL outside of just a WHERE clause, such as GROUP BY, ORDER BY, etc.
</p></div><dl class="paramcmts block"><dt class="param">columns</dt><dd class="cmt"><p>String of comma-separated columns to be SELECTed</p></dd><dt class="param">sourceTable</dt><dd class="cmt"><p>name of source table from which we SELECT</p></dd><dt class="param">destinationTable</dt><dd class="cmt"><p>name of destination table or view to be created from SELECT query</p></dd><dt class="param">whereClause</dt><dd class="cmt"><p>where clause of the SELECT query, including the literal &quot;WHERE&quot; keyword</p></dd><dt class="param">isView</dt><dd class="cmt"><p>true if generating a view, false if generating a table</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateViewAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateViewAsSelectSQL(selectQuery:String,destinationView:String):String"></a>
      <a id="getCreateViewAsSelectSQL(String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateViewAsSelectSQL</span><span class="params">(<span name="selectQuery">selectQuery: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationView">destinationView: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a view based on a SELECT query,
not necessarily from any particular table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a view based on a SELECT query,
not necessarily from any particular table. The entire SELECT query must be supplied
to generate something like &quot;CREATE VIEW destinationTable AS selectQuery&quot;.
This method is useful for calls to UDFs or stored procedures that might be database-specific
and don't conform to selecting columns from a source table.</p><p>Table name should be fully qualified and delimited, if necessary (i.e. &quot;schemaname&quot;.&quot;tablename&quot;).</p><p>selectQuery is not necessarily a SELECT query, but any query that can feed the CREATE TABLE statement.
</p></div><dl class="paramcmts block"><dt class="param">selectQuery</dt><dd class="cmt"><p>query (not necessary SELECT) to be used for CREATE VIEW</p></dd><dt class="param">destinationView</dt><dd class="cmt"><p>name of destination table to be created from SELECT query</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateViewAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateViewAsSelectSQL(columns:String,sourceTable:String,destinationView:String):String"></a>
      <a id="getCreateViewAsSelectSQL(String,String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateViewAsSelectSQL</span><span class="params">(<span name="columns">columns: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sourceTable">sourceTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationView">destinationView: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a view based on a SELECT query from an existing table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a view based on a SELECT query from an existing table.
For most databases, this is something like &quot;CREATE VIEW destinationTable AS SELECT columns FROM sourceTable&quot;</p><p>View names should be fully qualified and delimited, if necessary (i.e. &quot;schemaname&quot;.&quot;viewname&quot;).
it is acceptable to specify a table join as the source table (i.e. table1 INNER JOIN table2 ...),
but in such cases, column names might not be unique and full qualification and aliasing may be
required (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;aliasname&quot;)
</p></div><dl class="paramcmts block"><dt class="param">columns</dt><dd class="cmt"><p>String of comma-separated columns to be SELECTed</p></dd><dt class="param">sourceTable</dt><dd class="cmt"><p>name of source table from which we SELECT</p></dd><dt class="param">destinationView</dt><dd class="cmt"><p>name of destination view to be created from SELECT query</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getCreateViewAsSelectSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getCreateViewAsSelectSQL(columns:String,sourceTable:String,destinationView:String,whereClause:String):String"></a>
      <a id="getCreateViewAsSelectSQL(String,String,String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getCreateViewAsSelectSQL</span><span class="params">(<span name="columns">columns: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sourceTable">sourceTable: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destinationView">destinationView: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="whereClause">whereClause: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to generate a view based on a SELECT query from an existing table.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to generate a view based on a SELECT query from an existing table.
For most databases, this is something like
&quot;CREATE VIEW destinationTable AS SELECT columns FROM sourceTable [whereClause]&quot;</p><p>View names should be fully qualified and delimited, if necessary (i.e. &quot;schemaname&quot;.&quot;viewname&quot;).
it is acceptable to specify a table join as the source table (i.e. table1 INNER JOIN table2 ...),
but in such cases, column names might not be unique and full qualification and aliasing may be
required (i.e. &quot;schemaname&quot;.&quot;tablename&quot;.&quot;columnname&quot; AS &quot;aliasname&quot;)</p><p>The specified WHERE clause should include the &quot;WHERE&quot; keyword. Note that this is simply SQL that
is appended to the query as &quot;SELECT columns FROM sourceTable whereClause&quot; and can include other
SQL outside of just a WHERE clause, such as GROUP BY, ORDER BY, etc.
</p></div><dl class="paramcmts block"><dt class="param">columns</dt><dd class="cmt"><p>String of comma-separated columns to be SELECTed</p></dd><dt class="param">sourceTable</dt><dd class="cmt"><p>name of source table from which we SELECT</p></dd><dt class="param">destinationView</dt><dd class="cmt"><p>name of destination view to be created from SELECT query</p></dd><dt class="param">whereClause</dt><dd class="cmt"><p>where clause of the SELECT query, including the literal &quot;WHERE&quot; keyword</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getDropTableIfExistsSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getDropTableIfExistsSQL(tableName:String,cascade:Boolean):String"></a>
      <a id="getDropTableIfExistsSQL(String,Boolean):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getDropTableIfExistsSQL</span><span class="params">(<span name="tableName">tableName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="cascade">cascade: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to drop a table if it exists, and optionally, cascade the drop to dependent tables.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to drop a table if it exists, and optionally, cascade the drop to dependent tables.
For most databases, this is something like &quot;DROP TABLE IF EXISTS tableName [CASCADE]&quot;</p><p>NOTE: Not all databases support CASCADE DROP
</p></div><dl class="paramcmts block"><dt class="param">tableName</dt><dd class="cmt"><p>table to be dropped</p></dd><dt class="param">cascade</dt><dd class="cmt"><p>true if dependent objects should also be dropped</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getDropViewIfExistsSQL" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getDropViewIfExistsSQL(viewName:String,cascade:Boolean):String"></a>
      <a id="getDropViewIfExistsSQL(String,Boolean):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getDropViewIfExistsSQL</span><span class="params">(<span name="viewName">viewName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="cascade">cascade: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a SQL DDL statement to drop a view if it exists, and optionally, cascade the drop to dependent views.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a SQL DDL statement to drop a view if it exists, and optionally, cascade the drop to dependent views.
For most databases, this is something like &quot;DROP VIEW IF EXISTS viewName [CASCADE]&quot;</p><p>NOTE: Not all databases support CASCADE DROP
</p></div><dl class="paramcmts block"><dt class="param">viewName</dt><dd class="cmt"><p>view to be dropped</p></dd><dt class="param">cascade</dt><dd class="cmt"><p>true if dependent objects should also be dropped</p></dd><dt>returns</dt><dd class="cmt"><p>generated SQL statement
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getModuloExpression" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getModuloExpression(dividend:String,divisor:String):String"></a>
      <a id="getModuloExpression(String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getModuloExpression</span><span class="params">(<span name="dividend">dividend: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="divisor">divisor: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the expression for modulo division for this database.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the expression for modulo division for this database. This differs widely among databases.
For example, in PostgreSQL, this is &quot;dividend % divisor&quot;.
But in Oracle, this is &quot;MODULO(dividend, divisor)&quot;.
For this reason, we must pass in the expressions used for dividend and divisor.
</p></div><dl class="paramcmts block"><dt class="param">dividend</dt><dd class="cmt"><p>SQL expression for the dividend to be passed to the MODULO (can be a simple column name)</p></dd><dt class="param">divisor</dt><dd class="cmt"><p>SQL expression for the divisor to be passed to the MODULO (can be a simple number)</p></dd><dt>returns</dt><dd class="cmt"><p>a SQL expression for the given dividend modulo the given divisor
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getStandardDeviationFunctionName" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getStandardDeviationFunctionName:String"></a>
      <a id="getStandardDeviationFunctionName:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getStandardDeviationFunctionName</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the name of the standard deviation function to be used for this database.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the name of the standard deviation function to be used for this database.
For example, in PostgreSQL, this is &quot;stddev&quot;. Note that this is just the function name,
and does not include the argument. A typical SQL call would be &quot;stddev(expression)&quot;.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>name of the standard deviation function for the current database type
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#getVarianceFunctionName" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="getVarianceFunctionName:String"></a>
      <a id="getVarianceFunctionName:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getVarianceFunctionName</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the name of the variance function to be used for this database.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the name of the variance function to be used for this database.
For example, in PostgreSQL, this is &quot;variance&quot;. Note that this is just the function name,
and does not include the argument. A typical call would be &quot;variance(expression)&quot;.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>name of the variance function for the current database type
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#quoteChar" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="quoteChar:String"></a>
      <a id="quoteChar:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">quoteChar</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Character or String to use when quoting identifiers.</p><div class="fullcomment"><div class="comment cmt"><p>Character or String to use when quoting identifiers.
Typically, this is a double-quote (for PostgreSQL and other databases), but can be other characters
or even Strings for other platforms.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the character or characters to be used to delimit identifiers for this database type
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#quoteIdentifier" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="quoteIdentifier(s:String):String"></a>
      <a id="quoteIdentifier(String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">quoteIdentifier</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps an identifier in the appropriate quote character to preserve case and special characters.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps an identifier in the appropriate quote character to preserve case and special characters.
If there is no quoting mechanism for this database type, just return the argument.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>string to be delimited</p></dd><dt>returns</dt><dd class="cmt"><p>the given string, but with the appropriate delimiters for the current database type
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#quoteObjectName" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="quoteObjectName(schemaName:String,objectName:String):String"></a>
      <a id="quoteObjectName(String,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">quoteObjectName</span><span class="params">(<span name="schemaName">schemaName: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="objectName">objectName: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps a schema and table or view name in the appropriate quote character to preserve case and special characters.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps a schema and table or view name in the appropriate quote character to preserve case and special characters.
If schemaName is unspecified, quote only the objectName. Uses quoteIdentifier() for quoting.
</p></div><dl class="paramcmts block"><dt class="param">schemaName</dt><dd class="cmt"><p>the schema name of the object (or &quot;&quot; if none)</p></dd><dt class="param">objectName</dt><dd class="cmt"><p>the object name of the object</p></dd><dt>returns</dt><dd class="cmt"><p>a string composed of the given schema and object names, properly delimited
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#useAliasForSelectSubQueries" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="useAliasForSelectSubQueries:Boolean"></a>
      <a id="useAliasForSelectSubQueries:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">useAliasForSelectSubQueries</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If true, subqueries must be aliased.</p><div class="fullcomment"><div class="comment cmt"><p>If true, subqueries must be aliased. Some databases, such as Oracle, require subqueries
(queries that appear in the FROM clause) to be aliased. For example:</p><p>SELECT ...
FROM (
    SELECT ...
    FROM foo
    WHERE ...
    ) AS fooalias
WHERE ...
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if subqueries must be aliased, false if otherwise
</p></dd></dl></div>
    </li><li name="com.alpine.sql.SQLGenerator#escapeColumnName" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="escapeColumnName(s:String):String"></a>
      <a id="escapeColumnName(String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2016-04-22) Please use quoteIdentifier instead [Paul]">escapeColumnName</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wraps a column name in the appropriate quote character to preserve case and special characters.</p><div class="fullcomment"><div class="comment cmt"><p>Wraps a column name in the appropriate quote character to preserve case and special characters.
If there is no quoting mechanism for this database type, just return the argument.</p><p>Note: Deprecated -- please use quoteIdentifier instead.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>string to be delimited</p></dd><dt>returns</dt><dd class="cmt"><p>the given string, but with appropriate delimiters for the current database type
</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2016-04-22)</i> Please use quoteIdentifier instead [Paul]</p></dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../lib/template.js"></script>
    </body>
      </html>